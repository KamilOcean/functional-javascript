<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>高阶函数 Higher-order function</title>
<!-- 2015-10-26 Mon 00:04 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Jichao Ouyang" />
<meta  name="description" content="能作为参数或者返回值的函数"
 />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">高阶函数 Higher-order function</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. 高阶函数(Higher-order function)</a>
<ul>
<li><a href="#sec-1-1">1.1. Higher-order function</a>
<ul>
<li><a href="#sec-1-1-1">1.1.1. 函数作为参数</a></li>
<li><a href="#sec-1-1-2">1.1.2. 函数作为返回值</a></li>
</ul>
</li>
<li><a href="#sec-1-2">1.2. 柯里化 currying</a>
<ul>
<li><a href="#sec-1-2-1">1.2.1. 我们来看一个问题</a></li>
<li><a href="#sec-1-2-2">1.2.2. 柯里化函数接口</a></li>
<li><a href="#sec-1-2-3">1.2.3. 自动柯里化</a></li>
</ul>
</li>
<li><a href="#sec-1-3">1.3. 函数组合 function composition</a>
<ul>
<li><a href="#sec-1-3-1">1.3.1. Compose</a></li>
<li><a href="#sec-1-3-2">1.3.2. pipe</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 高阶函数(Higher-order function)</h2>
<div class="outline-text-2" id="text-1">
<p>
我们已经见识到了匿名函数和箭头函数的用法, 匿名的一等函数到底有什么用呢?
来看看高阶函数的应用.
</p>

<p>
高阶函数意思是它接收另一个函数作为参数. 为什么叫 <b>高阶</b>: 来看看这个函数
<code>f(x, y) = x(y)</code> 按照 lambda 的简化过程则是
</p>

<pre class="example">
f(x) =&gt; (y -&gt; x(y))
(y) =&gt; x(y)
</pre>

<p>
可以看出来调用 f 时却又返回了一个函数x.
</p>

<p>
还记得高等数学里面的导数吗, 两阶以上的导数叫高阶导数.
因为求导一次以后返回的可以求导.
</p>

<p>
概念是一样的,
如同<a href="https://en.wikipedia.org/wiki/Matryoshka_doll">俄罗斯套娃</a> 当函数执行以后还需执行或者要对参数执行,
因此叫高阶函数.
</p>


<div class="figure">
<p><img src="./images/higherorder/recursion.png" alt="recursion.png" />
</p>
</div>

<p>
高阶函数最常见的应用如 <code>map</code>, <code>reduce</code>.
他们都是以传入不同的函数来以不同的方式操作数组元素.
</p>

<p>
另外 <i>柯里化</i>, 则是每次消费一个参数并返回一个逐步被配置好的函数.
</p>
<p>
高阶函数的这些应用都是为函数的组合提供灵活性.
在本章结束相信你会很好的体会到函数组合的强大之处.
</p>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> Higher-order function</h3>
<div class="outline-text-3" id="text-1-1">
<p>
函数在 JavaScript 中是一等公民, 因此在 JavaScript 中, 使用高阶函数是非常方便的.
</p>
</div>

<div id="outline-container-sec-1-1-1" class="outline-4">
<h4 id="sec-1-1-1"><span class="section-number-4">1.1.1</span> 函数作为参数</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
假设我现在要对一个数组排序, 用我们熟悉的 <code>sort</code>
</p>

<div class="org-src-container">

<pre class="src src-js">[1,3,2,5,4].sort( (x, y) =&gt; x - y )
</pre>
</div>

<p>
如果我们要逆序的排序, 把减号左右的 <code>x</code> 和 <code>y</code> 呼唤,就这么简单,
但如果我是一个对象数组, 要根据对象的 <code>id</code> 排序:
</p>

<div class="org-src-container">

<pre class="src src-js">[{id:1, name:<span style="color: #66cccc;">'one'</span>},
 {id:3, name:<span style="color: #66cccc;">'three'</span>}, 
 {id:2, name:<span style="color: #66cccc;">'two'</span>}, 
 {id:5, name:<span style="color: #66cccc;">'five'</span>},  
 {id:4, name:<span style="color: #66cccc;">'four'</span>}].sort((x,y) =&gt; x.id - y.id)
</pre>
</div>

<p>
是不是已经能够感受到高阶函数与匿名函数组合的灵活性.
</p>
</div>
</div>

<div id="outline-container-sec-1-1-2" class="outline-4">
<h4 id="sec-1-1-2"><span class="section-number-4">1.1.2</span> 函数作为返回值</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
函数的返回值可以不只是值, 同样也可以是一个函数, 来看 Eweda
内部的一个工具函数 <code>aliasFor</code>, 他的作用是给函数 E 的一些方法起一些别名:
</p>

<blockquote>
<p>
听起来很怪不是吗, 函数怎么有方法, 实际上 JavaScript 的 <code>function</code>
是一个特殊 <b>对象</b>, 试试在 Firefox console 里敲 <code>console.log.</code>
是不是看到了一些方法, 但是 <code>typeof console.log</code> 是 function
</p>
</blockquote>

<div class="org-src-container">

<pre class="src src-js"><span style="color: #99cc99;">var</span> <span style="color: #ffcc66;">E</span> = () =&gt; {}
<span style="color: #99cc99;">var</span> <span style="color: #ffcc66;">aliasFor</span> = oldName =&gt; {
    <span style="color: #99cc99;">var</span> <span style="color: #ffcc66;">fn</span> = newName =&gt; {
      E[newName] = E[oldName];
      <span style="color: #99cc99;">return</span> fn;
    };
    <span style="color: #99cc99;">return</span> (fn.is = fn.are = fn.and = fn);
};
</pre>
</div>

<p>
这里有两个 <code>return</code>, 一个是 <code>fn</code> 返回自己, 另一个是 <code>aliasFor</code> 也返回
<code>fn</code>, 并且给 <code>fn</code> 了几个别名 <code>fn.is</code> <code>fn.are</code>&#x2026;
</p>

<p>
什么意思呢? <code>fn</code> 返回 <code>fn</code>. 很简单就是 <code>fn() =&gt; fn</code>,
那么 <code>fn()()=&gt;fn()=&gt;fn</code> &#x2026;以此类推, 无论调用 fn 多少次,都最终返回 fn.
</p>


<div class="figure">
<p><img src="./images/higherorder/1qUCC8s.png" alt="1qUCC8s.png" />
</p>
</div>

<p>
这到底有什么用呢, 由于这里使用了 <code>fn</code> 的副作用(side affect)
来干了一些事情 <code>E[newName]=E[oldName]</code>, 也就是给 E 的方法起一个别名,
因此每次调用 fn 都会给 <code>E</code> 起一个别名. <code>aliasFor</code> 最后返回的是 <code>fn</code>
自己的一些别名, 使得可以 chain 起来更可读一些:
</p>

<div class="org-src-container">

<pre class="src src-js">aliasFor(<span style="color: #66cccc;">'reduce'</span>).is(<span style="color: #66cccc;">'reduceLeft'</span>).is(<span style="color: #66cccc;">'foldl'</span>)
</pre>
</div>

<a class="jsbin-embed" href="http://jsbin.com/qohil/1/embed?js,console">完整代码</a><script src="http://static.jsbin.com/js/embed.js"></script>

<blockquote>
<p>
另外, 函数作为返回值的重要应用, 柯里化与闭包,
将会在在后面专门介绍. 我们先来看下以函数作为参数的高阶函数的典型应用.
</p>
</blockquote>
</div>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> 柯里化 currying</h3>
<div class="outline-text-3" id="text-1-2">
<p>
还记得 Haskell Curry吗
</p>


<div class="figure">
<p><img src="./images/higherorder/curry.png" alt="curry.png" />
</p>
</div>

<p>
多巧啊, 人家姓 Curry 名 Haskell, 难怪 Haskell 语言会自动柯里化, 呵呵.
但是不奇怪吗, 为什么要柯里化呢. 为什么如此重要得让 Haskell
会默认自动柯里化所有函数, 不就是返回一个部分配置好的函数吗.
</p>

<p>
我们来看一个 Haskell 的代码.
</p>

<div class="org-src-container">

<pre class="src src-haskell">max 3 4
(max 3) 4
</pre>
</div>

<p>
结果都是4, 这有什么用呢.
</p>

<p>
这里看不出来, 放到 <code>高阶函数</code> 试试. 什么? 看不懂天书 Haskell, 来看看
JavaScript 吧.
</p>
</div>

<div id="outline-container-sec-1-2-1" class="outline-4">
<h4 id="sec-1-2-1"><span class="section-number-4">1.2.1</span> 我们来看一个问题</h4>
<div class="outline-text-4" id="text-1-2-1">
</div><ol class="org-ol"><li><a id="sec-1-2-1-1" name="sec-1-2-1-1"></a>写一个函数, 可以连接字符数组, 如 f(['1','2']) =&gt; '12'<br  /><div class="outline-text-5" id="text-1-2-1-1">
<p>
好吧,如果不用柯里化, 怎么写? 啊哈 <code>reduce</code>
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="color: #99cc99;">var</span> <span style="color: #ffcc66;">concatArray</span> = <span style="color: #99cc99;">function</span>(<span style="color: #ffcc66;">chars</span>){
  <span style="color: #99cc99;">return</span> chars.reduce(<span style="color: #99cc99;">function</span>(<span style="color: #ffcc66;">a</span>, <span style="color: #ffcc66;">b</span>){
    <span style="color: #99cc99;">return</span> a.concat(b);
  });
}
concat([<span style="color: #66cccc;">'1'</span>,<span style="color: #66cccc;">'2'</span>,<span style="color: #66cccc;">'3'</span>]) <span style="color: #999999; font-style: italic;">// </span><span style="color: #999999; font-style: italic;">=&gt; '123'</span>
</pre>
</div>

<p>
很简单,对吧.
</p>
</div>
</li>

<li><a id="sec-1-2-1-2" name="sec-1-2-1-2"></a>现在我要其中所有数字加1, 然后在连接<br  /><div class="outline-text-5" id="text-1-2-1-2">
<div class="org-src-container">

<pre class="src src-js"><span style="color: #99cc99;">var</span> <span style="color: #ffcc66;">concatArray</span> = <span style="color: #99cc99;">function</span>(<span style="color: #ffcc66;">chars</span>, <span style="color: #ffcc66;">inc</span>){
  <span style="color: #99cc99;">return</span> chars.map(<span style="color: #99cc99;">function</span>(<span style="color: #6699cc;">char</span>){
    <span style="color: #99cc99;">return</span> (+<span style="color: #6699cc;">char</span>)+inc + <span style="color: #66cccc;">''</span>;
  }).reduce(<span style="color: #99cc99;">function</span>(<span style="color: #ffcc66;">a</span>,<span style="color: #ffcc66;">b</span>){
      <span style="color: #99cc99;">return</span> a.concat(b)
  });
}
console.log(concatArray([<span style="color: #66cccc;">'1'</span>,<span style="color: #66cccc;">'2'</span>,<span style="color: #66cccc;">'3'</span>], 1))<span style="color: #999999; font-style: italic;">// </span><span style="color: #999999; font-style: italic;">=&gt; '234'</span>
</pre>
</div>
</div>
</li>

<li><a id="sec-1-2-1-3" name="sec-1-2-1-3"></a>所有数字乘以2, 再重构试试看<br  /><div class="outline-text-5" id="text-1-2-1-3">
<div class="org-src-container">

<pre class="src src-js"><span style="color: #99cc99;">var</span> <span style="color: #ffcc66;">multiple</span> = <span style="color: #99cc99;">function</span>(<span style="color: #ffcc66;">a</span>, <span style="color: #ffcc66;">b</span>){
  <span style="color: #99cc99;">return</span> +a*b + <span style="color: #66cccc;">''</span>
}
<span style="color: #99cc99;">var</span> <span style="color: #ffcc66;">concatArray</span> = <span style="color: #99cc99;">function</span>(<span style="color: #ffcc66;">chars</span>, <span style="color: #ffcc66;">inc</span>){
  <span style="color: #99cc99;">return</span> chars.map(<span style="color: #99cc99;">function</span>(<span style="color: #6699cc;">char</span>){
    <span style="color: #99cc99;">return</span> multiple(<span style="color: #6699cc;">char</span>, inc);
  }).reduce(<span style="color: #99cc99;">function</span>(<span style="color: #ffcc66;">a</span>,<span style="color: #ffcc66;">b</span>){
      <span style="color: #99cc99;">return</span> a.concat(b)
  });
}
console.log(concatArray([<span style="color: #66cccc;">'1'</span>,<span style="color: #66cccc;">'2'</span>,<span style="color: #66cccc;">'3'</span>], 2)) <span style="color: #999999; font-style: italic;">// </span><span style="color: #999999; font-style: italic;">=&gt; '246'</span>
</pre>
</div>

<p>
是不是已经看出问题了呢?
如果我在需要每个数字都减2,是不是很麻烦呢.需要将 <code>map</code> 参数匿名函数中的
multiple 函数换掉. 这样一来 <code>concatArray</code> 就不能同时处理加, 乘和减?
那么怎么能把他提取出来呢? 来对比下柯里化的解法.
</p>
</div>
</li></ol>
</div>

<div id="outline-container-sec-1-2-2" class="outline-4">
<h4 id="sec-1-2-2"><span class="section-number-4">1.2.2</span> 柯里化函数接口</h4>
<div class="outline-text-4" id="text-1-2-2">
<div class="org-src-container">

<pre class="src src-js"><span style="color: #99cc99;">var</span> <span style="color: #ffcc66;">multiple</span> = <span style="color: #99cc99;">function</span>(<span style="color: #ffcc66;">a</span>){
  <span style="color: #99cc99;">return</span> <span style="color: #99cc99;">function</span>(<span style="color: #ffcc66;">b</span>){
    <span style="color: #99cc99;">return</span> +b*a + <span style="color: #66cccc;">''</span>
  }
}

<span style="color: #99cc99;">var</span> <span style="color: #ffcc66;">plus</span> = <span style="color: #99cc99;">function</span>(<span style="color: #ffcc66;">a</span>){
  <span style="color: #99cc99;">return</span> <span style="color: #99cc99;">function</span>(<span style="color: #ffcc66;">b</span>){
    <span style="color: #99cc99;">return</span> (+b)+a + <span style="color: #66cccc;">''</span>
  }
}
<span style="color: #99cc99;">var</span> <span style="color: #ffcc66;">concatArray</span> = <span style="color: #99cc99;">function</span>(<span style="color: #ffcc66;">chars</span>, <span style="color: #ffcc66;">stylishChar</span>){
  <span style="color: #99cc99;">return</span> chars.map(stylishChar)
    .reduce(<span style="color: #99cc99;">function</span>(<span style="color: #ffcc66;">a</span>,<span style="color: #ffcc66;">b</span>){
      <span style="color: #99cc99;">return</span> a.concat(b)
  });
}
console.log(concatArray([<span style="color: #66cccc;">'1'</span>,<span style="color: #66cccc;">'2'</span>,<span style="color: #66cccc;">'3'</span>], multiple(2)))
console.log(concatArray([<span style="color: #66cccc;">'1'</span>,<span style="color: #66cccc;">'2'</span>,<span style="color: #66cccc;">'3'</span>], plus(2)))
</pre>
</div>

<p>
有什么不一样呢 1. 处理数组中字符的函数被提取出来, 作为参数传入 2.
提取成柯里化的函数, 部分配置好后传入, 好处显而易见, 这下接口非常通畅
无论是外层调用
</p>

<pre class="example">
concatArray(['1','2','3'], multiple(2))
</pre>

<p>
还是内部的 map 函数
</p>

<pre class="example">
chars.map(stylishChar)
</pre>

<p>
这些接口都清晰了很多, 不是吗
</p>

<p>
这就是函数式的思想, 用已有的函数组合出新的函数, 而柯里化每消费一个参数,
都会返回一个新的部分配置的函数, 这为函数组合提供了更灵活的手段,
并且使得接口更为流畅.
</p>
</div>
</div>

<div id="outline-container-sec-1-2-3" class="outline-4">
<h4 id="sec-1-2-3"><span class="section-number-4">1.2.3</span> 自动柯里化</h4>
<div class="outline-text-4" id="text-1-2-3">
<p>
在 Haskell 语言中, 函数是会自动柯里化的:
</p>

<div class="org-src-container">

<pre class="src src-haskell">max 3 4
</pre>
</div>

<p>
其实就是
</p>

<pre class="example">
(max 3) 4
</pre>

<p>
可以看看 <code>max</code> 与 <code>max 3</code> 函数的 类型
</p>

<div class="org-src-container">

<pre class="src src-haskell">ghci&gt; :t max
max :: Ord a =&gt; a -&gt; a -&gt; a
</pre>
</div>

<p>
看明白了么, <code>Ord a =&gt;</code> 表示类型约束为可以比较大小的类型, 因此 <code>max</code>
的类型可以翻译成: 当给定一个 <code>a</code>, 会得到 <code>a -&gt; a</code>,
再看看 <code>max 3</code> 的类型就好理解了
</p>

<pre class="example">
ghci&gt; :t max 3
(Num a, Ord a) =&gt; a -&gt; a
</pre>

<p>
左侧表示类型约束 <code>a</code> 可以是 <code>Ord</code> 或者 <code>Num</code>,
意思是 <code>max 3</code> 还是一个函数,如果给定一个 <code>Ord</code> 或者 <code>Num</code> 类型的参数
则返回一个 <code>Ord</code> 或者 <code>Num</code>.
</p>

<p>
现在是不是清晰了, 在 Haskell 中每给定一个参数, 函数如果是多参数的,
该函数还会返回一个处理余下参数的函数. 这就是自动柯里化.
</p>

<p>
而在 Javascript(以及大多数语言) 中不是的, 如果给定多参函数的部分参数,
函数会默认其他参数是 <code>undefined</code>, 而不会返回处理剩余参数的函数.
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="color: #99cc99;">function</span> <span style="color: #f99157;">willNotCurry</span>(<span style="color: #ffcc66;">a</span>, <span style="color: #ffcc66;">b</span>, <span style="color: #ffcc66;">c</span>) {
    console.log(a, b, c)
    <span style="color: #99cc99;">return</span> a*b-c;
}
willNotCurry(1)
<span style="color: #999999; font-style: italic;">// </span><span style="color: #999999; font-style: italic;">=&gt; NaN</span>
<span style="color: #999999; font-style: italic;">// </span><span style="color: #999999; font-style: italic;">=&gt; 1 undefined undefined</span>
</pre>
</div>

<p>
如果使用自动柯里化的库 <a href="https://github.com/CrossEye/eweda">eweda</a>,
前面的例子简直就完美了
</p>

<pre class="example">
var multiple = curry(function(a, b){
  return +b*a + ''
})
var plus = curry(function(a, b){
  return (+b)+a + ''
})
</pre>

<a class="jsbin-embed" href="http://jsbin.com/hamoq/6/embed?js,console">完整代码</a><script src="http://static.jsbin.com/js/embed.js"></script>
</div>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> 函数组合 function composition</h3>
<div class="outline-text-3" id="text-1-3">
<p>
通过前面介绍的高阶函数, map, fold 以及柯里化,
其实已经见识到什么是函数组合了. 如之前例子中的 map 就是 由 fold 函数与
reverse 函数组合出来的.
</p>

<p>
这就是函数式的思想, 不断地用已有函数, 来组合出新的函数.
</p>


<div class="figure">
<p><img src="./images/higherorder/composition.jpg" alt="composition.jpg" />
</p>
</div>

<p>
如图就是函数组合，来自
<a href="https://en.wikipedia.org/wiki/Category_theory">Catgory Theory</a>（Funtor 也是从这来的，后面会讲到）, 既然从 A到B
有对应的映射f，B到 C有对应的映射g， 那么 <code>(g.f)(x)</code> 也就是 <code>f</code> 与 <code>g</code>
的组合 <code>g(f(x))</code> 就是 A到 C 的映射。上一章实现的 map 函数就相当于
<code>reverse.fold</code>.
</p>
</div>

<div id="outline-container-sec-1-3-1" class="outline-4">
<h4 id="sec-1-3-1"><span class="section-number-4">1.3.1</span> Compose</h4>
<div class="outline-text-4" id="text-1-3-1">
<p>
我们可以用 Eweda 非常方便的 compose 方法来组合函数
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="color: #99cc99;">var</span> <span style="color: #ffcc66;">gf</span> = E.compose(f, g)
</pre>
</div>

<p>
说到了函数组合, 柯里化, 我想现在终于可以解释清楚为什么在这里选用
Eweda/Ramda 而不是 Underscore 了.
</p>

<p>
举个例子🌰 如果我现在想要 tasks 列表中所有属性为 <code>completed</code> 为 <code>true</code>
的元素, 并按照 <code>id</code> 排序.
</p>

<p>
underscore 里会这样写:
</p>

<div class="org-src-container">

<pre class="src src-js">_(tasks)
    .chain()
    .filter( task =&gt; task.completed===<span style="color: #6699cc;">true</span>)
    .sortBy( task =&gt; task.id)
    .value();
</pre>
</div>

<p>
这种方式怎么看都不是函数式, 而是以对象/容器为中心的串联，有些像 jquery
对象的链式调用, 或者我们可以写的函数式一些, 如
</p>

<div class="org-src-container">

<pre class="src src-js">_.sortBy(_.filter(tasks, task =&gt; task.completed===<span style="color: #6699cc;">true</span>), task =&gt; task.id)
</pre>
</div>

<p>
恩恩, 看起来不错嘛, 但是有谁是这么用 underscore的呢. 一般都会只见过
链式调用才是 underscore 的标准写法。
</p>

<p>
来对比一下用 Eweda/Ramda 解决的过程 :
</p>

<div class="org-src-container">

<pre class="src src-js">compose(sortBy(task=&gt;task.id), filter(task=&gt;task.completed===<span style="color: #6699cc;">true</span>))(tasks)
</pre>
</div>

<p>
好像没什么区别啊? 不就是用了 compose 吗?
</p>

<p>
区别大了这, 看见 <code>tasks</code> 是最后当参数传给 <code>E.compose()</code> 的吗?
而不是写死在filter 的参数中. 这意味着在接到需要处理的数据前,
我已经组合好一个新的函数在等待数据, 而不是把数据混杂在中间,
或是保持在一个中间对象中. 而 underscore
的写法导致这一长串 <code>_.sortBy(_.filter())</code> 其实根本无法重用。
</p>

<p>
好吧如果你还看不出来这样做的好处. 那么来如果我有一个包含几组 tasks的列表
groupedTasks, 我要按类型选出 completed 为 true 并按 id 排序.
如我现在数据是这个：
</p>

<pre class="example">
groupedTasks = [
  [{completed:false, id:1},{completed:true, id:2}],
  [{completed:false, id:4},{completed:true, id:3}]
]
</pre>

<p>
underscore:
</p>

<div class="org-src-container">

<pre class="src src-js">_.map(groupedTasks,
   tasks =&gt; _.sortBy(_.filter(tasks, task =&gt; task.completed===<span style="color: #6699cc;">true</span>), task =&gt; task.id))
</pre>
</div>

<p>
看见我们又把 <code>_.sortBy(_.filter())</code> 这一长串原封不动的拷贝到了 map 里。
因为 underscore
一开始就要消费数据，使得很难重用，除非在套在另一个函数里：
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="color: #99cc99;">function</span> <span style="color: #f99157;">completedAndSorted</span>(<span style="color: #ffcc66;">tasks</span>){
  <span style="color: #99cc99;">return</span> _.sortBy(_.filter(tasks, task =&gt; task.completed===<span style="color: #6699cc;">true</span>), task =&gt; task.id))
}
_.map(groupedTasks, completedAndSorted)
</pre>
</div>

<p>
只有这样才能重用已有的一些函数。或者虽然 underscore 也有 <code>_.compose</code>
方法，但是 几乎所有 underscore
的方法都是先消费数据（也就是第一个参数是数据），使得很难放到 <code>compose</code>
方法中，不信可以尝试把 filter 和 sortBy 搁进去，反正我是做不到。
</p>

<p>
来看看真正的函数组合
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="color: #99cc99;">var</span> <span style="color: #ffcc66;">completedAndSorted</span> = compose(sortBy(task=&gt;task.id),
                                 filter(task=&gt;task.completed===<span style="color: #6699cc;">true</span>))
map(completedAndSorted, groupedTasks)
</pre>
</div>

<p>
看出来思想完全不一样了吧.
</p>

<p>
由于 Eweda/Ramda 的函数都是自动柯里化,而且数据总是最后一个参数,
因此可以随意组合, 最终将需要处理的数据扔给组合好的函数就好了.
这才是函数式的思想. 先写好一个公式，在把数据扔给
公式。而不是算好一部分再把结果给另一个公式。
</p>


<div class="figure">
<p><img src="./images/higherorder/ThreeFunctionMachines.jpg" alt="ThreeFunctionMachines.jpg" />
</p>
</div>

<p>
而 underscore 要么是以对象保持中间数据, 用 chaining
的方式对目标应用各种函数（书上会写这是Flow-Base
programming，但我觉得其实是 Monad，会在下一章中介绍）,
要么用函数嵌套函数, 将目标一层层传递下去.
</p>
</div>
</div>

<div id="outline-container-sec-1-3-2" class="outline-4">
<h4 id="sec-1-3-2"><span class="section-number-4">1.3.2</span> pipe</h4>
<div class="outline-text-4" id="text-1-3-2">
<p>
类似 compose, eweda/ramda 还有一个方法叫 pipe, pipe 的函数执行方向刚好与
compose 相反. 比如 <code>pipe(f, g)</code>, <code>f</code> 会先执行, 然后结果传给 <code>g</code>,
是不是让你想起了 bash 的 pipe
</p>

<pre class="example">
find / | grep porno
</pre>

<p>
实际上就是 <code>pipe(find, grep(porno))(/)</code>
</p>

<p>
没错,他们都是一个意思. 而且这个函数执行的方向更适合人脑编译(可读)一些.
</p>

<p>
如果你已经习惯 underscore 的这种写法
</p>

<div class="org-src-container">

<pre class="src src-js">_(data)
  .chain()
  .map(data1,fn1)
  .filter(data2, fn2)
  .value()
</pre>
</div>

<p>
那么转换成 pipe 是很容易的一件事情，而且更简单明了易于重用和组合。
</p>

<div class="org-src-container">

<pre class="src src-js">pipe(
  map(fn1),
  filter(fn2)
)(data)
</pre>
</div>

<a class="jsbin-embed" href="http://jsbin.com/hivaje/2/embed?js,console">完整代码</a><script src="http://static.jsbin.com/js/embed.js"></script>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Jichao Ouyang</p>
<p class="date">Created: 2015-10-26 Mon 00:04</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.5.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"></p>
</div>
</body>
</html>
